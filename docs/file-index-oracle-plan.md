# AIDIS Architectural Code Indexing - Oracle Implementation Plan

**Generated by Oracle AI on 2025-09-05**

## Overall Goal  
Persist a lightweight, always-up-to-date "architectural map" of each project so that any AI agent—at the start of a new session—can answer
• "What exists?" • "Where does a new feature belong?" • "Which modules interact?"

The map must be (a) cheap to build/update, (b) queriable in < 150 ms, and (c) decoupled from deep source-level embeddings.

## 1. Database Schema (PostgreSQL + pgvector)

Entity-relationship view (schema `arch`)

1. **projects**  
   `id (PK)  |  name  |  repo_url  |  created_at`

2. **snapshots**  
   `id (PK)  |  project_id (FK)  |  git_sha  |  created_at`  
   • Immutable record of every index build; enables diffing/time-travel.

3. **modules**  
   `id (PK)  |  snapshot_id (FK)  |  fqmn (unique per snapshot)`  
   `path_root`          (e.g., "web/src/features/auth")  
   `module_type`        (enum: domain, ui, infra, lib, shared, etc.)  
   `description`        (text; high-level summary)  
   `vector`             (pgvector(768) – embedding of description)  
   `loc_count, file_count`

4. **relations**  
   `id (PK)  |  snapshot_id (FK)`  
   `source_module_id (FK)  |  target_module_id (FK)`  
   `relation_type` (enum: import, api_call, db_access, event_bus, shared_state)  
   `evidence` (jsonb – files/lines supporting the edge)

5. **entry_points**  
   `id (PK) | snapshot_id (FK) | module_id (FK)`  
   `ep_type` (enum: http_route, cli_cmd, cron, pubsub_topic, ui_route)  
   `signature` (e.g., "POST /api/v1/orders")  
   `file_path | line_no | description | vector`

6. **naming_registry_links**  
   `module_id (FK) | registry_key (FK to existing naming table)`  
   Purpose: connect architectural concepts with user-friendly names.

**Indexes & Performance:**  
• GIN on relations→evidence->'files' for path searches  
• ivfflat index on vector columns for semantic search (cosine)

## 2. MCP Tools (APIs exposed to agents)

Suffix tools with `_arch` to avoid confusion.

1. **arch_index**(project_id, git_sha?|path?)  
   – Runs extraction pipeline, writes a new snapshot.  
   Options: diff_mode=true (only changed files).

2. **arch_search**(query, filters?)  
   – Hybrid BM25 + vector search across `modules` & `entry_points`.  
   Filters: module_type, ep_type, path_prefix, date_range.

3. **arch_explain**(fqmn)  
   – Returns module description, entry points, inbound/outbound relations.

4. **arch_graph**(snapshot_id?, depth?, focus_module?)  
   – Emits GraphQL-friendly JSON for UI visualisation.

5. **arch_diff**(from_sha, to_sha)  
   – Lists added/removed/changed modules and relations.

All tools respect existing project ACLs and log usage to decision tracker.

## 3. AI Analysis & Extraction Pipeline

Phases run inside `arch_index` tool:

### 0. Pre-flight  
• git checkout desired SHA (or receive file list from IDE).  
• Build path map; detect language(s).

### 1. Structural harvesting (deterministic)  
a. Directory heuristics (e.g., folders named `features/*`, `service/*`).  
b. Language-specific parsers (ts-morph, Python AST, Go/packages, etc.) to collect:  
   • top-level imports  
   • public interfaces / controllers / handlers  
   • framework registrations (React Router, NestJS modules, FastAPI endpoints).  
Output: raw graph = nodes(paths) + edges(imports/calls).

### 2. Module boundary detection  
• Collapse raw graph into higher-level "modules" using:  
  – Folder depth threshold (configurable)  
  – `package.json`/`go.mod`/`pyproject.toml` boundaries  
  – Presence of `index.ts`, `module.ts`, `__init__.py`.  
• Assign module_type via heuristics + rules file (`arch_rules.yml`).  
• Compute LOC, file_count.

### 3. LLM summarisation (architectural level)  
a. For each module:  
   Prompt = "Summarise purpose, main responsibilities, external contracts for module X given these file paths and top 20 symbol names."  
b. For each detected entry point:  
   Prompt = "Rewrite this route/signature in business terms."  
• Use small model first; fall back to GPT-4 only for new/changed modules.  
• Store text + embedding.

### 4. Relation enrichment  
• Map import edges to relation_type via language rules.  
• Detect infra interactions (DB, cache, message queue) by scanning for known client libs (e.g., `typeorm`, `redis`).  
• Tag edges with evidence (file_path + line numbers).

### 5. Persist snapshot, emit events  
• Write all entities in single transaction.  
• Publish `arch_snapshot_created` event → triggers project timeline update.

**Incremental strategy:**  
• Keep SHA of last indexed commit. When diff_mode, rerun steps 1-4 only for changed/impacted modules; delete stale ones.

## 4. Integration with Existing AIDIS Systems

### 1. Context Storage & Search  
• On session start, AIDIS loads latest architectural snapshot into in-memory cache.  
• When agent stores a new context chunk, link it to `module_id` via fuzzy path match → richer retrieval.

### 2. Technical Decision Tracking  
• Decisions include `affected_modules` array (FK to modules table).  
• When a new snapshot changes a module referenced by an open decision, trigger "decision re-check" warning.

### 3. Project & Task Management  
• Task object gains `target_module_id` and `entry_point_signature` fields (optional).  
• Sprint board can filter tasks by module or relation cluster.

### 4. Naming Registry  
• Modules auto-register suggested human-readable names (LLM can propose).  
• Manual override possible; updates propagate to `modules.description`.

### 5. Security / ACL  
• Leverage existing project permission model.  
• `arch_search` enforces `view_code` or finer scopes.

## Milestones & Resourcing

### Phase 0 (1 wk) – Spike  
• Prototype structural harvesting for TypeScript + Python repos.  
• Write SQL migration scripts; create `arch` schema.

### Phase 1 (3 wks) – Core Indexer & Basic Search  
• Implement steps 0-3 for TS/Python, diff_mode indexing, arch_search/explain tools.  
• Integrate into session bootstrap; measure perf on 5 OSS repos.

### Phase 2 (2 wks) – Relations & Visual Graph  
• Edge typing, entry point detection, arch_graph API, UI component.

### Phase 3 (2 wks) – Incremental updates & Cross-system hooks  
• Snapshot diffing, decision/task linking, ACL hardening.

### Phase 4 (ongoing) – Language/Framework packs  
• Go, Java/Kotlin, C#.  
• Community-maintained rule sets in `arch_rules.yml`.

## Operational Considerations

• Re-index automatically on merges to main and nightly for long-lived branches.  
• Cap snapshot retention (e.g., last 100) with archive to S3.  
• Alert on index runtime > 5 min or snapshot size delta > 20%.

## Key Benefits

• Agents can answer architecture questions from day-1 without crawling thousands of files.  
• Stable module+relation IDs unlock higher-level reasoning (impact analysis, dependency mapping).  
• Lightweight embeddings keep vector store small (~1 MB per 100 modules).  

This plan delivers a pragmatic, incrementally deployable architectural indexing layer that fits cleanly into AIDIS and dramatically shortens the "cold-start" time for AI agents.
